/*
 * This file is to hold the entirety of the LISP core.
 * None of the functions in the core are to interface with the stack.
 * Stack functions are placed in stack.h.
 * The functions here have stack-based versions prefixed by 's_'.
 * Those functions are in dict.h, which itself is generated by gen_dict.
 */

#ifndef LISP_H
#define LISP_H
#define CASE_INSENSITIVE
#include <stdlib.h>
// Type definitions
typedef enum {false,true} bool;
typedef enum {CELL,SYMBOL,INTEGER,FUNCTION,DOUBLE} type_t;
typedef struct {
	type_t type;
	long car,cdr;
	int refs;
} obj_t;
// Memory management
#define new(x) malloc(sizeof(x));
obj_t *new_obj(type_t type,long car,long cdr)
{
	obj_t *obj=new(obj_t);
	obj->type=type;
	obj->car=car;
	obj->cdr=cdr;
	obj->refs=0;
	return obj;
}
void dec_rc(obj_t *);
void destroy(obj_t *obj)
{
	switch (obj->type) {
	case SYMBOL:
	case FUNCTION:
		free((void *)obj->car);
	case DOUBLE:
	case INTEGER:
		free(obj);
		break;
	case CELL:
		dec_rc((obj_t *)obj->car);
		dec_rc((obj_t *)obj->cdr);
		free(obj);
	}
}
void rcdestroy(obj_t *obj)
{
	if (obj->refs==0)
		destroy(obj);
}
void inc_rc(obj_t *obj)
{
	if (0xff>(long)obj)
		return;
	if (obj->refs>=0)
		obj->refs++;
}
void dec_rc(obj_t *obj)
{
	if (0xff>(long)obj)
		return;
	if (obj->refs>0)
		obj->refs--;
	if (obj->refs==0)
		destroy(obj);
}
// Constants
#define CONSTANT(x) {	\
	.type=SYMBOL,	\
	.car=(long)#x,	\
	.cdr=0,		\
	.refs=-1	\
}
obj_t NIL_OBJ=CONSTANT(NIL);
obj_t *NIL=&NIL_OBJ;
obj_t T_OBJ=CONSTANT(T);
obj_t *T=&T_OBJ;
obj_t SELF_OBJ=CONSTANT(@);
obj_t *SELF=&SELF_OBJ;
// LISP core functions
#define core(name,argc) obj_t * // Info for dictionary code generator
core(CAR,1) car(obj_t *obj)
{
	if (obj->type==CELL)
		return (obj_t *)obj->car;
	return NIL;
}
core(CDR,1) cdr(obj_t *obj)
{
	if (obj->type==CELL)
		return (obj_t *)obj->cdr;
	return NIL;
}
core(CONS,2) cons(obj_t *obj1,obj_t *obj2)
{
	inc_rc(obj1);
	inc_rc(obj2);
	return new_obj(CELL,(long)obj1,(long)obj2);
}
void print_cell(obj_t *);
core(PRINT,1) print(obj_t *obj)
{
	switch (obj->type) {
	case CELL:
		print_cell(obj);
		break;
	case SYMBOL:
		printf("%s",(char *)obj->car);
		break;
	case INTEGER:
		printf("%ld",obj->car);
		break;
	case FUNCTION:
		printf("{FUNCTION 0x%lx}",(long)obj);
		break;
	case DOUBLE:
		printf("%f",(double)obj->car);
		break;
	default:
		printf("{ERROR}");
	}
	return obj;
}
void print_cell(obj_t *obj)
{
	putchar('(');
	obj_t *o=obj;
	while (o!=NIL) {
		if (o->type!=CELL) {
			fputs(". ",stdout);
			print(o);
			putchar(')');
			return;
		}
		print(car(o));
		if ((obj_t *)o->cdr!=NIL)
			putchar(' ');
		o=(obj_t *)o->cdr;
	}
	putchar(')');
}
core(TERPRI,0) terpri() {
	putchar('\n');
	return NIL;
}
core(EQ,2) eq(obj_t *obj1,obj_t *obj2)
{
	if (obj1==obj2)
		return T;
	// The addresses are not equal
	if (obj1->type!=obj2->type)
		return NIL;
	// The types are equal
	switch (obj1->type) {
	case CELL:
		return NIL;
	case SYMBOL:
		return strcasecmp((char *)obj1->car,(char *)obj2->car)?NIL:T;
	case INTEGER:
	case DOUBLE:
		return obj1->car==obj2->car?T:NIL;
	case FUNCTION:
		return NIL;
	}
}
core(SET,2) set(obj_t *obj1,obj_t *obj2)
{
	if (obj1->refs<0)
		return NIL;
	// Free memory from old contents if appropriate
	switch (obj1->type) {
	case CELL:
		dec_rc((obj_t *)obj1->car);
		dec_rc((obj_t *)obj1->cdr);
		break;
	case FUNCTION:
	case SYMBOL:
		free((void *)obj1->car);
	default:
		break;
	}
	// Prepare new memory areas if appropriate
	long size=obj2->cdr;
	switch (obj2->type) {
	case SYMBOL:
	case FUNCTION:
		obj1->car=(long)malloc(size);
		memcpy((void *)obj1->car,(void *)obj2->car,size);
		break;
	case CELL:
		inc_rc((obj_t *)obj2->car);
		inc_rc((obj_t *)obj2->cdr);
	default:
		obj1->car=obj2->car;
	}
	obj1->type=obj2->type;
	obj1->cdr=obj2->cdr;
	return obj1;
}
#endif
